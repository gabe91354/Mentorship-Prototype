<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Mentorship System (Sets + Promote)</title>
  <style>
    body { font-family: Arial, sans-serif; padding: 20px; }
    input, select, button { margin: 5px 0; }
    #mentorSection, #menteeSection, #adminSection { margin-top: 20px; }
    ul { margin-left: 20px; }

    /* Tree styling */
    .tree {
      display: flex;
      justify-content: center;
      align-items: flex-start;
      flex-direction: column;
      gap: 20px;
    }
    .node {
      display: inline-block;
      text-align: center;
      padding: 10px 18px;
      margin: 10px;
      background-color: #f6f9ff;
      border: 2px solid #2b6cb0;
      border-radius: 8px;
      position: relative;
      min-width: 100px;
    }
    .node small { display:block; color:#333; font-size:11px; margin-top:6px; }
    .line-down {
      width: 2px;
      height: 18px;
      background-color: #888;
      margin: 0 auto;
    }
    .children {
      display: flex;
      justify-content: center;
      align-items: flex-start;
      position: relative;
      gap: 10px;
      margin-top: 6px;
    }
    .children::before {
      content: "";
      position: absolute;
      top: 0;
      left: 0;
      right: 0;
      height: 2px;
      background: #888;
    }
    .children .node::before {
      content: "";
      position: absolute;
      top: -18px;
      left: 50%;
      width: 2px;
      height: 18px;
      background: #888;
      transform: translateX(-50%);
    }

    .controls { margin-top: 8px; }
    .promoteBtn { margin-left: 8px; }
  </style>
</head>
<body>
  <h1>Mentorship System (Sets + Promote)</h1>

  <!-- Login -->
  <div id="loginDiv">
    <h2>Login / Register</h2>
    <input type="text" id="username" placeholder="Enter your name" />
    <select id="rank">
      <option value="mentor">Mentor</option>
      <option value="mentee">Mentee</option>
      <option value="admin">Admin</option>
    </select>
    <button onclick="login()">Login</button>
  </div>

  <!-- Mentor Section -->
  <div id="mentorSection" style="display:none;">
    <h2>Welcome, Mentor!</h2>
    <div class="controls">
      <input type="text" id="newMentee" placeholder="Add mentee name" />
      <button onclick="addMentee()">Add Mentee</button>
      <button onclick="viewMyTree()">View My Tree</button>
      <button onclick="logout()">Logout</button>
    </div>
    <h3>Your Mentees:</h3>
    <ul id="menteeList"></ul>
    <div id="myTreeContainer"></div>
  </div>

  <!-- Mentee Section -->
  <div id="menteeSection" style="display:none;">
    <h2>Welcome, Mentee!</h2>
    <p>Waiting for mentor to add you...</p>
    <button onclick="logout()">Logout</button>
  </div>

  <!-- Admin Section -->
  <div id="adminSection" style="display:none;">
    <h2>Admin Panel</h2>
    <div class="controls">
      <button onclick="removeAllRecords()">Remove All Records</button>
      <button onclick="logout()">Logout</button>
    </div>
    <h3>Mentorship Trees (Sets)</h3>
    <div id="treeContainer"></div>
  </div>

<script>
/*
 Data model stored in localStorage:
 users: [{ name, rank: 'mentor'|'mentee'|'admin', mentees: [...names], set: number }]
 sets: [1,2,...]   (list of set ids; new set created by push)
*/

// load or initialize
let users = JSON.parse(localStorage.getItem('users')) || [];
let sets = JSON.parse(localStorage.getItem('sets')) || [1];

// helper: persist
function saveAll() {
  localStorage.setItem('users', JSON.stringify(users));
  localStorage.setItem('sets', JSON.stringify(sets));
}

/* ---------- Authentication / UI ---------- */

let currentUser = null;

function login() {
  const name = document.getElementById('username').value.trim();
  const rank = document.getElementById('rank').value;
  if (!name) { alert('Please enter a name.'); return; }

  let user = users.find(u => u.name === name);
  if (!user) {
    // new registration => place in latest set
    user = { name, rank, mentees: [], set: sets[sets.length - 1] };
    users.push(user);
    saveAll();
    alert(`Registered ${name} as ${rank} in set #${user.set}`);
  }
  currentUser = user;
  showUserSection(user);
}

function logout() {
  currentUser = null;
  document.getElementById('loginDiv').style.display = '';
  document.getElementById('mentorSection').style.display = 'none';
  document.getElementById('menteeSection').style.display = 'none';
  document.getElementById('adminSection').style.display = 'none';
  document.getElementById('myTreeContainer').innerHTML = '';
}

/* ---------- UI Display ---------- */

function showUserSection(user) {
  document.getElementById('loginDiv').style.display = 'none';
  document.getElementById('myTreeContainer').innerHTML = '';

  if (user.rank === 'mentor') {
    document.getElementById('mentorSection').style.display = 'block';
    document.getElementById('menteeSection').style.display = 'none';
    document.getElementById('adminSection').style.display = 'none';
    updateMenteeList(user);
  } else if (user.rank === 'mentee') {
    document.getElementById('mentorSection').style.display = 'none';
    document.getElementById('menteeSection').style.display = 'block';
    document.getElementById('adminSection').style.display = 'none';
  } else if (user.rank === 'admin') {
    document.getElementById('mentorSection').style.display = 'none';
    document.getElementById('menteeSection').style.display = 'none';
    document.getElementById('adminSection').style.display = 'block';
    renderHierarchyTree();
  }
}

/* ---------- Core logic ---------- */

// Calculate generation level within a specific set.
// Level 1 => top (no mentor in set). If a user has a mentor in same set, recursion increases level.
function getUserGenerationInSet(name, setNum, level = 1) {
  // find mentor in same set who has this user as mentee
  const mentor = users.find(u => u.set === setNum && u.mentees.includes(name));
  if (!mentor) return level;
  return getUserGenerationInSet(mentor.name, setNum, level + 1);
}

// Add mentee (mentor can add only registered mentees and only those in same set allowed)
function addMentee() {
  if (!currentUser || currentUser.rank !== 'mentor') return alert('Only mentors can add mentees.');
  const newMenteeName = document.getElementById('newMentee').value.trim();
  if (!newMenteeName) return alert('Enter mentee name.');

  const mentee = users.find(u => u.name === newMenteeName);
  if (!mentee) return alert('This mentee is not registered yet. Only registered users can be added.');

  // ensure mentee is rank mentee (not admin). You can allow adding existing mentors if desired; here we require rank === 'mentee'
  if (mentee.rank !== 'mentee') return alert('You can only add users who are registered as mentees.');

  // mentor's set and generation
  const mentor = currentUser;
  const mentorLevel = getUserGenerationInSet(mentor.name, mentor.set);

  if (mentorLevel >= 5) {
    // We reached limit â€” we want to create a new set and move this mentee to that new set as a mentor.
    const newSetId = sets.length + 1;
    sets.push(newSetId);
    // promote mentee to mentor in new set
    mentee.rank = 'mentor';
    mentee.mentees = []; // start fresh
    mentee.set = newSetId;
    saveAll();
    alert(`Generation limit reached (5). ${mentee.name} was promoted and moved to new mentorship set #${newSetId}.`);
    // refresh mentor's mentee list (we did not add this mentee to current mentor)
    updateMenteeList(mentor);
    // If admin is visible, refresh
    if (currentUser && currentUser.rank === 'admin') renderHierarchyTree();
    return;
  }

  // normal add: add mentee to mentor's mentees if not already and set mentee's set to mentor's set
  if (!mentor.mentees.includes(newMenteeName)) {
    mentor.mentees.push(newMenteeName);
    mentee.set = mentor.set; // place mentee in same set
    saveAll();
    updateMenteeList(mentor);
    if (currentUser && currentUser.rank === 'admin') renderHierarchyTree();
  } else {
    alert(`${newMenteeName} is already in your mentee list.`);
  }
  document.getElementById('newMentee').value = '';
}

// update mentor's mentee list and show promote button
function updateMenteeList(mentor) {
  const list = document.getElementById('menteeList');
  list.innerHTML = '';
  if (!mentor.mentees || mentor.mentees.length === 0) {
    const li = document.createElement('li');
    li.textContent = 'No mentee recorded';
    list.appendChild(li);
    return;
  }

  mentor.mentees.forEach(mName => {
    const li = document.createElement('li');
    li.textContent = mName + ` (set #${getUserSet(mName)})`;

    const promoteBtn = document.createElement('button');
    promoteBtn.textContent = 'Promote to Mentor';
    promoteBtn.className = 'promoteBtn';
    promoteBtn.onclick = () => {
      promoteMenteeFlow(mName, mentor.name);
    };

    // determine promotion possibility: if promoting in same set would exceed limit then show note but still allow promotion (it will create new set)
    const menteeSet = getUserSet(mName);
    const menteeLevelInSet = getUserGenerationInSet(mName, menteeSet);
    if (menteeLevelInSet >= 5) {
      promoteBtn.title = 'Promoting will move this user to a new set (already at generation 5 in current set).';
    }

    li.appendChild(promoteBtn);
    list.appendChild(li);
  });
}

// helper: get user's set number (defaults to last set if missing)
function getUserSet(name) {
  const u = users.find(x => x.name === name);
  return u ? u.set : sets[sets.length - 1];
}

/* Promote flow: mentor promotes menteeName; we implement the logic described:
   - Find mentee object
   - Check their generation in the mentor's set (we want to know if promotion stays in same set or needs new set)
   - If promote would remain within <=5, change rank to mentor and keep set
   - If promotion would exceed 5, create new set and move promoted user there as mentor
   - Save and refresh UI
*/
function promoteMenteeFlow(menteeName, promoterName) {
  const mentee = users.find(u => u.name === menteeName);
  if (!mentee) return alert('User not found.');

  if (mentee.rank === 'mentor') return alert(`${menteeName} is already a mentor.`);

  // promoter's set
  const promoter = users.find(u => u.name === promoterName);
  const promoterSet = promoter ? promoter.set : getUserSet(promoterName);

  // compute mentee generation within promoter's set (if mentee isn't in same set, treat as top)
  const inSameSet = mentee.set === promoterSet;
  const menteeLevelInPromoterSet = inSameSet ? getUserGenerationInSet(menteeName, promoterSet) : 1;

  if (menteeLevelInPromoterSet < 5) {
    // safe to promote within same set
    mentee.rank = 'mentor';
    // keep mentee.set as promoterSet (if previously different, unify)
    mentee.set = promoterSet;
    saveAll();
    alert(`${menteeName} has been promoted to mentor in set #${promoterSet}.`);
  } else {
    // would exceed 5 -> create new set and move them there as mentor
    const newSetId = sets.length + 1;
    sets.push(newSetId);
    mentee.rank = 'mentor';
    mentee.mentees = mentee.mentees || [];
    mentee.set = newSetId;
    saveAll();
    alert(`${menteeName} was at generation 5 â€” moved and promoted to new mentorship set #${newSetId}.`);
  }

  // refresh current mentor's list if logged-in mentor
  if (currentUser && currentUser.rank === 'mentor') {
    const mentorObj = users.find(u => u.name === currentUser.name);
    updateMenteeList(mentorObj);
    // also show updated small tree for mentor if viewed
    viewMyTree();
  }
  // refresh admin view if open
  if (currentUser && currentUser.rank === 'admin') renderHierarchyTree();
}

/* ---------- Admin tree rendering (per-set) ---------- */

function renderHierarchyTree() {
  const treeContainer = document.getElementById('treeContainer');
  treeContainer.innerHTML = '';

  // iterate sets
  sets.forEach(setNum => {
    const section = document.createElement('div');
    section.style.marginBottom = '24px';
    const header = document.createElement('h3');
    header.textContent = `Set #${setNum}`;
    section.appendChild(header);

    // find roots in this set (mentors in set who are not mentees of anyone in same set)
    const roots = users.filter(u => u.set === setNum && u.rank === 'mentor' && !users.some(x => x.set === setNum && x.mentees.includes(u.name)));
    if (roots.length === 0) {
      const p = document.createElement('p');
      p.textContent = 'No mentors recorded for this set.';
      section.appendChild(p);
      treeContainer.appendChild(section);
      return;
    }

    const tree = document.createElement('div');
    tree.className = 'tree';
    roots.forEach(root => {
      tree.appendChild(buildNodeWithLimit(root, 1, setNum));
    });
    section.appendChild(tree);
    treeContainer.appendChild(section);
  });
}

// Build tree node but stop after 5 levels in given set
function buildNodeWithLimit(user, level, setNum) {
  const nodeDiv = document.createElement('div');
  nodeDiv.className = 'node';
  nodeDiv.innerHTML = `<strong>${user.name}</strong><small>${user.rank} â€¢ set #${user.set}</small>`;

  if (user.mentees && user.mentees.length > 0 && level < 5) {
    const down = document.createElement('div');
    down.className = 'line-down';
    nodeDiv.appendChild(down);

    const container = document.createElement('div');
    container.className = 'children';
    user.mentees.forEach(mName => {
      // only show children in same set
      const mObj = users.find(x => x.name === mName && x.set === setNum);
      if (mObj) container.appendChild(buildNodeWithLimit(mObj, level + 1, setNum));
    });
    nodeDiv.appendChild(container);
  }

  return nodeDiv;
}

/* ---------- Mentor personal tree view ---------- */

function viewMyTree() {
  if (!currentUser || currentUser.rank !== 'mentor') return alert('Only mentors can view their tree here.');
  const container = document.getElementById('myTreeContainer');
  container.innerHTML = '';
  const root = users.find(u => u.name === currentUser.name);
  if (!root) return;
  const tree = document.createElement('div');
  tree.className = 'tree';
  tree.appendChild(buildNodeWithLimit(root, 1, root.set));
  container.appendChild(tree);
}

/* ---------- Utilities ---------- */

function removeAllRecords() {
  if (!confirm('Are you sure you want to remove all records?')) return;
  users = [];
  sets = [1];
  saveAll();
  localStorage.removeItem('users');
  localStorage.removeItem('sets');
  location.reload();
}

/* ---------- Initial debug: (optional) create sample data if none exist) ---------- */
// (comment out if you don't want auto-sample)
// if (users.length === 0) {
//   users = [
//     { name: 'Alice', rank: 'mentor', mentees: ['Bob','Carol'], set: 1 },
//     { name: 'Bob', rank: 'mentor', mentees: ['Dave'], set: 1 },
//     { name: 'Carol', rank: 'mentee', mentees: [], set: 1 },
//     { name: 'Dave', rank: 'mentee', mentees: [], set: 1 },
//   ];
//   saveAll();
//}
</script>
</body>
</html>
